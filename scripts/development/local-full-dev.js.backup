// Complete local development environment with Frontend + Backend + Real Supabase
import dotenv from 'dotenv';
import express from 'express';
import cors from 'cors';
import { createClient } from '@supabase/supabase-js';
import { spawn } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';

// Load environment variables FIRST, before any other imports
dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const API_PORT = 3003;
const FRONTEND_PORT = 5175;

// Middleware
app.use(cors({
  origin: true, // Allow all origins in development
  credentials: true
}));
app.use(express.json());

// Supabase configuration (using environment variables)
const supabaseUrl = process.env.SUPABASE_URL || 'https://wxpwxzdgdvinlbtnbgdf.supabase.co';
const supabaseKey = process.env.SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind4cHd4emRnZHZpbmxidG5iZ2RmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAxOTk1ODAsImV4cCI6MjA2NTc3NTU4MH0.YMai9p4VQMbdqmc_9uWGeJ6nONHwuM9XT2FDTFy0aGk';
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

// Regular Supabase client (for general operations)
const supabase = createClient(supabaseUrl, supabaseKey);

// Admin Supabase client (for admin operations that need service role)
const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey || supabaseKey);

console.log('üîë Supabase Configuration:');
console.log('   URL:', supabaseUrl);
console.log('   Service Role Key:', supabaseServiceKey ? '‚úÖ Set' : '‚ùå Missing');

// Test accounts
const TEST_ACCOUNTS = {
  participant: {
    email: 'abwanwr77+participant@gmail.com',
    password: 'Testtest123',
    role: 'participant'
  },
  researcher: {
    email: 'abwanwr77+Researcher@gmail.com', 
    password: 'Testtest123',
    role: 'researcher'
  },
  admin: {
    email: 'abwanwr77+admin@gmail.com',
    password: 'Testtest123',
    role: 'admin'
  }
};

// ===== Import consolidated API handlers =====
import authHandler from '../../api/auth-consolidated.js';
import templatesHandler from '../../api/templates-consolidated.js';
import paymentsHandler from '../../api/payments-consolidated-full.js';
import userProfileHandler from '../../api/user-profile-consolidated.js';
import systemHandler from '../../api/system-consolidated.js';
import researchHandler from '../../api/research-consolidated.js';
import adminHandler from '../../api/admin-consolidated.js';

// === CONSOLIDATED API ROUTES ===

// Auth endpoints
app.all('/api/auth*', async (req, res) => {
  await authHandler(req, res);
});

// Database check
app.get('/api/db-check', async (req, res) => {
  try {
    // Test database connection
    const { data, error } = await supabase
      .from('profiles')
      .select('count', { count: 'exact' })
      .limit(1);

    if (error) {
      throw error;
    }

    res.json({
      success: true,
      message: 'Database connection successful',
      profileCount: data?.length || 0,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Database check error:', error);
    res.status(500).json({
      success: false,
      error: 'Database connection failed',
      message: error.message
    });
  }
});

// Research endpoints: studies, applications, sessions, blocks
  const { action } = req.query;
  
  try {
    console.log(`üîê LOCAL AUTH ACTION: ${action}`);

    // REGISTER
    if (action === 'register') {
      const { email, password, firstName, lastName, role = 'participant' } = req.body;
      
      if (!email || !password || !firstName || !lastName) {
        return res.status(400).json({
          success: false,
          error: 'All fields are required'
        });
      }

      const { data, error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: {
            first_name: firstName,
            last_name: lastName,
            role: role
          }
        }
      });

      if (error) {
        console.error('Registration error:', error);
        return res.status(400).json({
          success: false,
          error: error.message
        });
      }

      // Create profile
      if (data.user) {
        const { error: profileError } = await supabase
          .from('profiles')
          .insert({
            id: data.user.id,
            email: data.user.email,
            first_name: firstName,
            last_name: lastName,
            role: role,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          });

        if (profileError) {
          console.error('Profile creation error:', profileError);
        }
      }

      console.log('User registered successfully - Role:', role);
      return res.status(201).json({
        success: true,
        message: 'Registration successful. Please check your email to confirm your account.',
        user: {
          id: data.user?.id,
          email: data.user?.email,
          role: role
        }
      });
    }

    // LOGIN
    if (action === 'login') {
      const { email, password } = req.body;
      
      if (!email || !password) {
        return res.status(400).json({
          success: false,
          error: 'Email and password are required'
        });
      }

      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) {
        console.error('Login error:', error);
        return res.status(401).json({
          success: false,
          error: error.message
        });
      }

      // Get user profile
      const { data: profile } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', data.user.id)
        .single();

      // Get role from profile first, then from user metadata, with fallback
      const userRole = profile?.role || data.user.user_metadata?.role || 'participant';
      const userStatus = profile?.status || 'active';
      
      // Check if user is active (especially important for participants)
      if (userStatus === 'inactive') {
        // Sign out the user immediately
        await supabase.auth.signOut();
        
        return res.status(403).json({
          success: false,
          error: userRole === 'participant' 
            ? 'Your account is pending admin verification. Please wait for approval before logging in.'
            : 'Your account has been deactivated. Please contact an administrator.',
          code: 'ACCOUNT_INACTIVE'
        });
      }
      
      // If no profile exists, create one with the correct role
      if (!profile) {
        console.log('Creating missing profile for user:', data.user.email);
        const { error: profileError } = await supabase
          .from('profiles')
          .insert({
            id: data.user.id,
            email: data.user.email,
            first_name: data.user.user_metadata?.first_name || '',
            last_name: data.user.user_metadata?.last_name || '',
            role: data.user.user_metadata?.role || 'participant',
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          });
        
        if (profileError) {
          console.error('Profile creation error:', profileError);
        } else {
          console.log('Profile created successfully with role:', data.user.user_metadata?.role || 'participant');
        }
      }      console.log('User logged in successfully - Role:', userRole);
      return res.status(200).json({
        success: true,
        message: 'Login successful',
        user: {
          id: data.user.id,
          email: data.user.email,
          role: userRole,
          firstName: profile?.first_name || data.user.user_metadata?.first_name,
          lastName: profile?.last_name || data.user.user_metadata?.last_name
        },
        session: {
          access_token: data.session.access_token,
          refresh_token: data.session.refresh_token,
          expires_at: data.session.expires_at
        }
      });
    }

    // STATUS
    if (action === 'status') {
      const authHeader = req.headers.authorization;
      const token = authHeader?.replace('Bearer ', '');

      if (!token) {
        return res.status(401).json({
          success: false,
          error: 'No token provided'
        });
      }

      const { data: { user }, error } = await supabase.auth.getUser(token);

      if (error || !user) {
        console.error('Token validation error:', error);
        return res.status(401).json({
          success: false,
          error: 'Invalid token'
        });
      }

      // Get user profile
      const { data: profile } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', user.id)
        .single();

      // Get role from profile first, then from user metadata, with fallback
      const userRole = profile?.role || user.user_metadata?.role || 'participant';

      console.log('Token validated successfully - Role:', userRole);
      return res.status(200).json({
        success: true,
        message: 'Token is valid',
        user: {
          id: user.id,
          email: user.email,
          role: userRole,
          firstName: profile?.first_name || user.user_metadata?.first_name,
          lastName: profile?.last_name || user.user_metadata?.last_name,
          emailConfirmed: user.email_confirmed_at !== null
        }
      });
    }

    // LOGOUT
    if (action === 'logout') {
      const authHeader = req.headers.authorization;
      const token = authHeader?.replace('Bearer ', '');

      if (token) {
        await supabase.auth.signOut();
      }

      return res.status(200).json({
        success: true,
        message: 'Logout successful'
      });
    }

    return res.status(400).json({
      success: false,
      error: 'Invalid action'
    });

  } catch (error) {
    console.error(`‚ùå AUTH ${action?.toUpperCase()} ERROR:`, error);
    
    res.status(500).json({
      success: false,
      error: `Auth ${action} failed`,
      message: error.message
    });
  }
});

// Profile endpoints
app.all('/api/profile', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    const token = authHeader?.replace('Bearer ', '');

    if (!token) {
      return res.status(401).json({
        success: false,
        error: 'No token provided'
      });
    }

    const { data: { user }, error } = await supabase.auth.getUser(token);

    if (error || !user) {
      return res.status(401).json({
        success: false,
        error: 'Invalid token'
      });
    }

    if (req.method === 'GET') {
      // Get profile
      const { data: profile } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', user.id)
        .single();

      return res.status(200).json({
        success: true,
        profile: profile || {
          id: user.id,
          email: user.email,
          first_name: user.user_metadata?.first_name || '',
          last_name: user.user_metadata?.last_name || '',
          role: user.user_metadata?.role || 'participant'
        }
      });
    }

    if (req.method === 'PUT') {
      // Update profile
      const { firstName, lastName } = req.body;

      const { data, error } = await supabase
        .from('profiles')
        .update({
          first_name: firstName,
          last_name: lastName,
          updated_at: new Date().toISOString()
        })
        .eq('id', user.id)
        .select()
        .single();

      if (error) {
        return res.status(400).json({
          success: false,
          error: error.message
        });
      }

      return res.status(200).json({
        success: true,
        message: 'Profile updated successfully',
        profile: data
      });
    }

  } catch (error) {
    console.error('Profile error:', error);
    res.status(500).json({
      success: false,
      error: 'Profile operation failed',
      message: error.message
    });
  }
});

// Studies endpoints - import the actual handler
import studiesHandler from '../../api/studies.js';
import walletsHandler from '../../api/wallets.js';
import templatesHandler from '../../api/templates-simple.js';
// PHASE 1 ENHANCED ENDPOINTS
import migrationHandler from '../../api/migration.js';
import userEnhancedHandler from '../../api/user-enhanced.js';
// PHASE 2 ENHANCED AUTHENTICATION
import authEnhancedHandler from '../../api/auth-enhanced.js';

>>>>>>> 0143a82207ffa6b8799d53ba39a6d3cfa1f2b452
app.all('/api/studies*', async (req, res) => {
  await researchHandler(req, res);
});

app.all('/api/research-consolidated*', async (req, res) => {
  await researchHandler(req, res);
});

app.all('/api/applications*', async (req, res) => {
  await researchHandler(req, res);
});

app.all('/api/study-sessions*', async (req, res) => {
  await researchHandler(req, res);
});

app.all('/api/blocks*', async (req, res) => {
  await researchHandler(req, res);
});

// Payments & Wallets endpoints
app.all('/api/wallets*', async (req, res) => {
  await paymentsHandler(req, res);
});

app.all('/api/payments*', async (req, res) => {
  await paymentsHandler(req, res);
});

// Templates endpoints
app.all('/api/templates*', async (req, res) => {
  await templatesHandler(req, res);
});

<<<<<<< HEAD
// User profile endpoints
app.all('/api/profile*', async (req, res) => {
  await userProfileHandler(req, res);
=======
// PHASE 1 ENHANCED ENDPOINTS - Database Migration and User Management
app.all('/api/migration*', async (req, res) => {
  await migrationHandler(req, res);
});

app.all('/api/user-enhanced*', async (req, res) => {
  await userEnhancedHandler(req, res);
});

// PHASE 2 ENHANCED AUTHENTICATION - JWT validation and role-based access
app.all('/api/auth-enhanced*', async (req, res) => {
  await authEnhancedHandler(req, res);
});

// Redirect study-builder endpoints to studies API with action=build
app.all('/api/study-builder*', async (req, res) => {
  // Redirect study-builder requests to studies API with action=build
  req.url = req.url.replace('/api/study-builder', '/api/studies?action=build');
  await studiesHandler(req, res);
>>>>>>> 0143a82207ffa6b8799d53ba39a6d3cfa1f2b452
});

app.all('/api/user-profile*', async (req, res) => {
  await userProfileHandler(req, res);
});

app.all('/api/user-enhanced*', async (req, res) => {
  await userProfileHandler(req, res);
});

// System endpoints
app.all('/api/health*', async (req, res) => {
  await systemHandler(req, res);
});

app.all('/api/system*', async (req, res) => {
  await systemHandler(req, res);
});

app.all('/api/dashboard*', async (req, res) => {
  await systemHandler(req, res);
});

app.all('/api/migration*', async (req, res) => {
  await systemHandler(req, res);
});

<<<<<<< HEAD
// Admin endpoints
app.all('/api/admin*', async (req, res) => {
  await adminHandler(req, res);
=======
// Admin User Actions (Create, Update, Delete)
app.all('/api/admin/user-actions', async (req, res) => {
  try {
    // Get Authorization header
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ success: false, error: 'No token provided' });
    }

    // Verify the user is authenticated and is an admin
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      return res.status(401).json({ success: false, error: 'Invalid token' });
    }

    // Check if user is admin
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (!profile || profile.role !== 'admin') {
      return res.status(403).json({ success: false, error: 'Admin access required' });
    }

    if (req.method === 'POST') {
      // Create new user
      const { email, password, name, role = 'participant', isActive = true } = req.body;

      if (!email || !password || !name) {
        return res.status(400).json({ 
          success: false, 
          error: 'Email, password, and name are required' 
        });
      }

      console.log('Creating new user:', { email, name, role, isActive });

      // Create user in Supabase Auth
      const { data: authData, error: authCreateError } = await supabaseAdmin.auth.admin.createUser({
        email,
        password,
        email_confirm: true,
        user_metadata: {
          first_name: name.split(' ')[0] || name,
          last_name: name.split(' ').slice(1).join(' ') || '',
        }
      });

      if (authCreateError) {
        console.error('Auth user creation error:', authCreateError);
        return res.status(400).json({ 
          success: false, 
          error: authCreateError.message 
        });
      }

      // Create or update profile (upsert to handle potential auto-creation)
      const { data: profileData, error: profileError } = await supabaseAdmin
        .from('profiles')
        .upsert({
          id: authData.user.id,
          email,
          first_name: name.split(' ')[0] || name,
          last_name: name.split(' ').slice(1).join(' ') || '',
          role,
          status: isActive ? 'active' : 'inactive',
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .select()
        .single();

      if (profileError) {
        console.error('Profile creation error:', profileError);
        // If profile creation fails, delete the auth user
        await supabaseAdmin.auth.admin.deleteUser(authData.user.id);
        return res.status(400).json({ 
          success: false, 
          error: profileError.message 
        });
      }

      console.log('User created successfully:', profileData);

      return res.status(201).json({
        success: true,
        data: {
          _id: profileData.id,
          name: `${profileData.first_name} ${profileData.last_name}`.trim(),
          email: profileData.email,
          role: profileData.role,
          isActive: profileData.status === 'active',
          createdAt: profileData.created_at,
          lastLoginAt: null,
          subscription: 'free',
          studiesCreated: 0,
          studiesParticipated: 0
        }
      });
    }

    if (req.method === 'PUT') {
      // Update existing user
      const { userId } = req.query;
      const { name, role, isActive } = req.body;

      if (!userId) {
        return res.status(400).json({ 
          success: false, 
          error: 'User ID is required' 
        });
      }

      console.log('Updating user:', userId, { name, role, isActive });

      const updateData = {
        updated_at: new Date().toISOString()
      };

      if (name) {
        updateData.first_name = name.split(' ')[0] || name;
        updateData.last_name = name.split(' ').slice(1).join(' ') || '';
      }

      if (role) {
        updateData.role = role;
      }

      if (typeof isActive === 'boolean') {
        updateData.status = isActive ? 'active' : 'inactive';
      }

      const { data: updatedProfile, error: updateError } = await supabaseAdmin
        .from('profiles')
        .update(updateData)
        .eq('id', userId)
        .select()
        .single();

      if (updateError) {
        console.error('Profile update error:', updateError);
        return res.status(400).json({ 
          success: false, 
          error: updateError.message 
        });
      }

      console.log('User updated successfully:', updatedProfile);

      return res.status(200).json({
        success: true,
        data: {
          _id: updatedProfile.id,
          name: `${updatedProfile.first_name} ${updatedProfile.last_name}`.trim(),
          email: updatedProfile.email,
          role: updatedProfile.role,
          isActive: updatedProfile.status === 'active',
          createdAt: updatedProfile.created_at,
          lastLoginAt: updatedProfile.last_login,
          subscription: 'free',
          studiesCreated: 0,
          studiesParticipated: 0
        }
      });
    }

    return res.status(405).json({ 
      success: false, 
      error: 'Method not allowed' 
    });

  } catch (error) {
    console.error('User action error:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
>>>>>>> 0143a82207ffa6b8799d53ba39a6d3cfa1f2b452
});

app.all('/api/subscriptions*', async (req, res) => {
  await adminHandler(req, res);
});

<<<<<<< HEAD
app.all('/api/points*', async (req, res) => {
  await adminHandler(req, res);
=======
// Analytics handler functions
async function handleOverviewAnalytics(res, supabase, config) {
  try {
    // Get real user counts
    const { count: totalUsers } = await supabase
      .from('profiles')
      .select('*', { count: 'exact', head: true });

    const { count: totalStudies } = await supabase
      .from('studies')
      .select('*', { count: 'exact', head: true });

    const { count: activeStudies } = await supabase
      .from('studies')
      .select('*', { count: 'exact', head: true })
      .eq('status', 'active');

    // Calculate estimated platform revenue
    const estimatedResearcherSpending = totalStudies * config.STUDY_BASE_COST;
    const estimatedParticipantEarnings = totalStudies * config.PARTICIPANT_BASE_REWARD;
    const estimatedPlatformProfit = estimatedResearcherSpending - estimatedParticipantEarnings;

    const analytics = {
      totalUsers: totalUsers || 0,
      totalStudies: totalStudies || 0,
      activeStudies: activeStudies || 0,
      totalRevenue: (estimatedResearcherSpending * 0.1).toFixed(2),
      researcherSpending: (estimatedResearcherSpending * 0.1).toFixed(2),
      participantEarnings: (estimatedParticipantEarnings * 0.1).toFixed(2),
      platformProfit: (estimatedPlatformProfit * 0.1).toFixed(2),
      conversionRate: config.PARTICIPANT_CONVERSION_RATE,
      platformFeePercent: config.PLATFORM_FEE_PERCENT,
      withdrawalFeePercent: config.WITHDRAWAL_FEE_PERCENT
    };

    return res.status(200).json({
      success: true,
      data: analytics
    });

  } catch (error) {
    console.error('Overview analytics error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to generate overview analytics'
    });
  }
}

async function handleStudyEconomics(res, supabase, config) {
  try {
    // Get studies with basic information (avoiding non-existent columns)
    const { data: studies, error } = await supabase
      .from('studies')
      .select(`
        id,
        title,
        status,
        created_at,
        creator_id
      `)
      .limit(50)
      .order('created_at', { ascending: false });

    if (error) throw error;

    // Get creator information separately to avoid foreign key issues
    const creatorIds = [...new Set(studies.map(study => study.creator_id).filter(Boolean))];
    const { data: creators } = await supabase
      .from('profiles')
      .select('id, email, first_name, last_name')
      .in('id', creatorIds);

    // Create a map of creators for quick lookup
    const creatorsMap = {};
    if (creators) {
      creators.forEach(creator => {
        creatorsMap[creator.id] = creator;
      });
    }

    if (error) throw error;

    const studyEconomics = studies.map(study => {
      // Use default values since actual block data may not be available
      const blockCount = 5; // Default block count
      const targetParticipants = 10; // Default participant target
      const creator = creatorsMap[study.creator_id];
      
      // Calculate costs
      const baseCost = config.STUDY_BASE_COST;
      const blockCost = Math.max(0, blockCount - config.MAX_BLOCKS_FREE) * config.COST_PER_BLOCK;
      const participantCost = Math.max(0, targetParticipants - config.MAX_PARTICIPANTS_FREE) * config.COST_PER_PARTICIPANT;
      const totalResearcherCost = baseCost + blockCost + participantCost;
      
      // Calculate participant earnings
      const baseReward = config.PARTICIPANT_BASE_REWARD;
      const blockBonus = blockCount * config.PARTICIPANT_BONUS_PER_BLOCK;
      const totalParticipantEarnings = (baseReward + blockBonus) * targetParticipants;
      
      // Calculate platform profit
      const platformProfit = totalResearcherCost - totalParticipantEarnings;
      const profitMargin = totalResearcherCost > 0 ? ((platformProfit / totalResearcherCost) * 100).toFixed(1) : '0.0';
      
      return {
        id: study.id,
        title: study.title,
        status: study.status,
        createdAt: study.created_at,
        creator: creator ? `${creator.first_name} ${creator.last_name}` : 'Unknown',
        creatorEmail: creator?.email || 'Unknown',
        blockCount,
        targetParticipants,
        researcherCost: (totalResearcherCost * config.PARTICIPANT_CONVERSION_RATE).toFixed(2),
        participantEarnings: (totalParticipantEarnings * config.PARTICIPANT_CONVERSION_RATE).toFixed(2),
        platformProfit: (platformProfit * config.PARTICIPANT_CONVERSION_RATE).toFixed(2),
        profitMargin: profitMargin
      };
    });

    return res.status(200).json({
      success: true,
      data: {
        studies: studyEconomics,
        summary: {
          totalStudies: studies.length,
          totalRevenue: studyEconomics.reduce((sum, study) => sum + parseFloat(study.researcherCost), 0).toFixed(2),
          totalParticipantEarnings: studyEconomics.reduce((sum, study) => sum + parseFloat(study.participantEarnings), 0).toFixed(2),
          totalPlatformProfit: studyEconomics.reduce((sum, study) => sum + parseFloat(study.platformProfit), 0).toFixed(2)
        }
      }
    });

  } catch (error) {
    console.error('Study economics error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to generate study economics data'
    });
  }
}

async function handleParticipantEarnings(res, supabase, config) {
  try {
    // Get participant profiles
    const { data: participants, error } = await supabase
      .from('profiles')
      .select('id, email, first_name, last_name, created_at')
      .eq('role', 'participant')
      .limit(50)
      .order('created_at', { ascending: false });

    if (error) throw error;

    const participantEarnings = participants.map(participant => {
      // Mock earnings data - in real implementation, this would come from study_sessions
      const completedStudies = Math.floor(Math.random() * 10) + 1;
      const totalPointsEarned = completedStudies * (config.PARTICIPANT_BASE_REWARD + 3);
      const cashValue = totalPointsEarned * config.PARTICIPANT_CONVERSION_RATE;
      
      return {
        id: participant.id,
        email: participant.email,
        name: `${participant.first_name} ${participant.last_name}`,
        joinedAt: participant.created_at,
        completedStudies,
        totalPointsEarned,
        cashValue: cashValue.toFixed(2),
        averageEarningsPerStudy: (totalPointsEarned / completedStudies).toFixed(1),
        status: 'active'
      };
    });

    return res.status(200).json({
      success: true,
      data: {
        participants: participantEarnings,
        summary: {
          totalParticipants: participants.length,
          totalPointsEarned: participantEarnings.reduce((sum, p) => sum + p.totalPointsEarned, 0),
          totalCashValue: participantEarnings.reduce((sum, p) => sum + parseFloat(p.cashValue), 0).toFixed(2),
          averageEarningsPerParticipant: (participantEarnings.reduce((sum, p) => sum + parseFloat(p.cashValue), 0) / participants.length).toFixed(2)
        }
      }
    });

  } catch (error) {
    console.error('Participant earnings error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to generate participant earnings data'
    });
  }
}

async function handlePlatformSettings(res, supabase, config) {
  try {
    // Return current platform settings
    const settings = {
      studyCosts: {
        baseCost: config.STUDY_BASE_COST,
        costPerBlock: config.COST_PER_BLOCK,
        costPerParticipant: config.COST_PER_PARTICIPANT,
        maxBlocksFree: config.MAX_BLOCKS_FREE,
        maxParticipantsFree: config.MAX_PARTICIPANTS_FREE
      },
      participantRewards: {
        baseReward: config.PARTICIPANT_BASE_REWARD,
        bonusPerBlock: config.PARTICIPANT_BONUS_PER_BLOCK,
        conversionRate: config.PARTICIPANT_CONVERSION_RATE,
        minWithdrawal: config.PARTICIPANT_MIN_WITHDRAWAL
      },
      platformFees: {
        platformFeePercent: config.PLATFORM_FEE_PERCENT,
        withdrawalFeePercent: config.WITHDRAWAL_FEE_PERCENT
      },
      security: {
        maxWithdrawalPerDay: config.MAX_WITHDRAWAL_PER_DAY,
        fraudDetectionThreshold: config.FRAUD_DETECTION_THRESHOLD
      }
    };

    return res.status(200).json({
      success: true,
      data: settings
    });

  } catch (error) {
    console.error('Platform settings error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to retrieve platform settings'
    });
  }
}

async function handleSettingsUpdate(req, res, supabase, adminId) {
  try {
    const { key, value, description } = req.body;
    
    if (!key || value === undefined) {
      return res.status(400).json({
        success: false,
        error: 'Key and value are required'
      });
    }

    // Log the settings update attempt
    console.log(`Admin ${adminId} attempting to update setting: ${key} = ${value}`);

    // In a real implementation, this would update the database
    // For now, we'll just return success
    return res.status(200).json({
      success: true,
      data: {
        key,
        value,
        updatedBy: adminId,
        updatedAt: new Date().toISOString(),
        description: description || `Updated ${key} setting`
      }
    });

  } catch (error) {
    console.error('Settings update error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to update settings'
    });
  }
}

async function handleFraudDetection(res, supabase, config) {
  try {
    // Mock fraud detection data
    const alerts = [
      {
        id: 'alert-1',
        type: 'high_earnings',
        severity: 'medium',
        participantId: 'mock-participant-1',
        description: 'Participant earned unusually high amount in short time',
        amount: 150,
        timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
        status: 'pending'
      },
      {
        id: 'alert-2',
        type: 'multiple_attempts',
        severity: 'low',
        participantId: 'mock-participant-2',
        description: 'Multiple study completion attempts detected',
        attempts: 5,
        timestamp: new Date(Date.now() - 6 * 60 * 60 * 1000).toISOString(),
        status: 'reviewed'
      }
    ];

    return res.status(200).json({
      success: true,
      data: {
        alerts,
        summary: {
          totalAlerts: alerts.length,
          pendingAlerts: alerts.filter(a => a.status === 'pending').length,
          highSeverityAlerts: alerts.filter(a => a.severity === 'high').length,
          lastScanTime: new Date().toISOString()
        }
      }
    });

  } catch (error) {
    console.error('Fraud detection error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to retrieve fraud detection data'
    });
  }
}

// Admin Analytics Overview - Real Data Endpoint  
app.get('/api/admin/analytics-overview', async (req, res) => {
  try {
    // Get Authorization header
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ success: false, error: 'No token provided' });
    }

    // Verify the user is authenticated and is an admin
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      return res.status(401).json({ success: false, error: 'Invalid token' });
    }

    // Check if user is admin
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (!profile || profile.role !== 'admin') {
      return res.status(403).json({ success: false, error: 'Admin access required' });
    }

    // Get real user count
    const { count: userCount } = await supabase
      .from('profiles')
      .select('*', { count: 'exact', head: true });

    // Get real study count
    const { count: studyCount } = await supabase
      .from('studies')
      .select('*', { count: 'exact', head: true });

    // Get active studies
    const { count: activeStudies } = await supabase
      .from('studies')
      .select('*', { count: 'exact', head: true })
      .eq('status', 'active');

    // Get new users this week
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    
    const { count: newUsersThisWeek } = await supabase
      .from('profiles')
      .select('*', { count: 'exact', head: true })
      .gte('created_at', oneWeekAgo.toISOString());

    // Get recent activity (recent user registrations and study creations)
    const { data: recentUsers } = await supabase
      .from('profiles')
      .select('first_name, last_name, email, created_at')
      .order('created_at', { ascending: false })
      .limit(5);

    const { data: recentStudies } = await supabase
      .from('studies')
      .select('title, creator_id, created_at, profiles!inner(first_name, last_name, email)')
      .order('created_at', { ascending: false })
      .limit(5);

    // Format recent activity
    const recentActivity = [
      ...(recentUsers || []).map(user => ({
        id: `user_${user.email}`,
        type: 'user_registered',
        description: 'New user registered',
        timestamp: user.created_at,
        user: user.email
      })),
      ...(recentStudies || []).map(study => ({
        id: `study_${study.title}`,
        type: 'study_created',
        description: `Study "${study.title}" created`,
        timestamp: study.created_at,
        user: study.profiles.email
      }))
    ].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)).slice(0, 10);

    // Analytics data with real values
    const analytics = {
      totalUsers: userCount || 0,
      activeStudies: activeStudies || 0,
      monthlyRevenue: 12450, // TODO: Calculate from real payment data
      totalParticipants: Math.floor((userCount || 0) * 0.7), // Estimate 70% are participants
      newUsersThisWeek: newUsersThisWeek || 0,
      completedStudies: studyCount || 0,
      systemHealth: 'healthy',
      recentActivity
    };

    return res.status(200).json({ success: true, data: analytics });
  } catch (error) {
    console.error('Analytics overview error:', error);
    return res.status(500).json({ success: false, error: error.message });
  }
});

// Admin Studies Endpoint
app.all('/api/admin/studies', async (req, res) => {
  try {
    // Get Authorization header
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ success: false, error: 'No token provided' });
    }

    // Verify user and check admin role
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    
    if (authError || !user) {
      return res.status(401).json({ success: false, error: 'Invalid token' });
    }

    // Get user profile to check role
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (profileError || !profile || profile.role !== 'admin') {
      return res.status(403).json({ success: false, error: 'Admin access required' });
    }

    console.log('üìö Admin Studies request from:', user.email);

    if (req.method === 'GET') {
      // Get all studies with researcher info
      const { data: studies, error: studiesError } = await supabase
        .from('studies')
        .select(`
          id,
          title,
          description,
          status,
          created_at,
          researcher_id,
          profiles!studies_researcher_id_fkey (
            id,
            first_name,
            last_name,
            email
          )
        `)
        .order('created_at', { ascending: false });

      if (studiesError) {
        console.error('Error fetching studies:', studiesError);
        return res.status(500).json({ success: false, error: 'Failed to fetch studies' });
      }

      const formattedStudies = studies.map(study => ({
        _id: study.id,
        title: study.title,
        description: study.description,
        status: study.status,
        researcher: {
          _id: study.profiles?.id || study.researcher_id,
          name: `${study.profiles?.first_name || ''} ${study.profiles?.last_name || ''}`.trim() || 'Unknown',
          email: study.profiles?.email || 'Unknown'
        },
        createdAt: study.created_at,
        participantCount: Math.floor(Math.random() * 50) // Mock data
      }));

      const response = {
        data: formattedStudies,
        pagination: {
          current: 1,
          total: 1,
          hasNext: false,
          hasPrev: false
        }
      };

      return res.status(200).json({
        success: true,
        data: response
      });
    }

    return res.status(405).json({ success: false, error: 'Method not allowed' });

  } catch (error) {
    console.error('Studies endpoint error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to process request'
    });
  }
});

// Admin Bulk Users Endpoint
app.put('/api/admin/users/bulk', async (req, res) => {
  try {
    // Get Authorization header
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ success: false, error: 'No token provided' });
    }

    // Verify user and check admin role
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    
    if (authError || !user) {
      return res.status(401).json({ success: false, error: 'Invalid token' });
    }

    // Get user profile to check role
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (profileError || !profile || profile.role !== 'admin') {
      return res.status(403).json({ success: false, error: 'Admin access required' });
    }

    console.log('üë• Admin Bulk Users operation from:', user.email);

    const { userIds, action, value } = req.body;

    if (!userIds || !Array.isArray(userIds) || userIds.length === 0) {
      return res.status(400).json({ success: false, error: 'User IDs array is required' });
    }

    if (!action) {
      return res.status(400).json({ success: false, error: 'Action is required' });
    }

    // Simulate bulk operation
    const result = {
      modifiedCount: userIds.length,
      matchedCount: userIds.length
    };

    console.log(`Bulk ${action} operation on ${userIds.length} users:`, result);

    return res.status(200).json({
      success: true,
      data: result
    });

  } catch (error) {
    console.error('Bulk users endpoint error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to perform bulk operation'
    });
  }
});

// Admin Financial Endpoint
app.get('/api/admin/financial', async (req, res) => {
  try {
    // Get Authorization header
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ success: false, error: 'No token provided' });
    }

    // Verify user and check admin role
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    
    if (authError || !user) {
      return res.status(401).json({ success: false, error: 'Invalid token' });
    }

    // Get user profile to check role
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (!profile || profile.role !== 'admin') {
      return res.status(403).json({ success: false, error: 'Admin access required' });
    }    console.log('üí∞ Admin Financial report request from:', user.email);

    // Get real financial data from Supabase
    const { timeframe = '30d' } = req.query;
    
    // Calculate date range based on timeframe
    const now = new Date();
    let startDate = new Date(now);
    
    switch (timeframe) {
      case '7d':
        startDate.setDate(now.getDate() - 7);
        break;
      case '30d':
        startDate.setDate(now.getDate() - 30);
        break;
      case '90d':
        startDate.setDate(now.getDate() - 90);
        break;
      case '1y':
        startDate.setFullYear(now.getFullYear() - 1);
        break;
      default:
        startDate.setDate(now.getDate() - 30);
    }

    // Get subscription counts and revenue data
    const { data: subscriptions, error: subError } = await supabase
      .from('users')
      .select('id, subscription_plan, subscription_status, created_at')
      .not('subscription_plan', 'is', null)
      .gte('created_at', startDate.toISOString());

    if (subError) {
      console.error('Subscription query error:', subError);
    }

    // Get user data for growth calculations
    const { data: allUsers, error: userError } = await supabase
      .from('users')
      .select('id, subscription_plan, subscription_status, created_at')
      .gte('created_at', startDate.toISOString());

    if (userError) {
      console.error('User query error:', userError);
    }

    // Calculate financial metrics
    const activeSubscriptions = (subscriptions || []).filter(s => s.subscription_status === 'active').length;
    const cancelledSubscriptions = (subscriptions || []).filter(s => s.subscription_status === 'cancelled').length;
    const totalCustomers = (allUsers || []).length;
    
    // Revenue calculation based on subscription tiers
    const revenuePerPlan = {
      'basic': 29,
      'pro': 79,
      'enterprise': 199
    };
    
    let totalRevenue = 0;
    let monthlyRevenue = 0;
    const planRevenue = { basic: 0, pro: 0, enterprise: 0 };
    
    (subscriptions || []).forEach(sub => {
      const planRevenue_amount = revenuePerPlan[sub.subscription_plan] || 29;
      totalRevenue += planRevenue_amount;
      
      // Track revenue by plan
      const plan = sub.subscription_plan?.toLowerCase();
      if (planRevenue[plan] !== undefined) {
        planRevenue[plan] += planRevenue_amount;
      }
      
      // Calculate if subscription was created this month
      const subDate = new Date(sub.created_at);
      const thisMonth = new Date();
      thisMonth.setDate(1);
      if (subDate >= thisMonth) {
        monthlyRevenue += planRevenue_amount;
      }
    });

    // Create revenue trends for the past 30 days
    const revenueTrends = [];
    for (let i = 29; i >= 0; i--) {
      const day = new Date();
      day.setDate(day.getDate() - i);
      const dayStart = new Date(day.getFullYear(), day.getMonth(), day.getDate());
      const dayEnd = new Date(day.getFullYear(), day.getMonth(), day.getDate() + 1);
      
      const daySubscriptions = (subscriptions || []).filter(s => {
        const subDate = new Date(s.created_at);
        return subDate >= dayStart && subDate < dayEnd;
      });
      
      const dayRevenue = daySubscriptions.reduce((sum, sub) => {
        return sum + (revenuePerPlan[sub.subscription_plan] || 29);
      }, 0);
      
      revenueTrends.push({
        date: day.toISOString().split('T')[0],
        revenue: dayRevenue
      });
    }

    const financialReport = {
      summary: {
        totalRevenue: totalRevenue,
        activeSubscriptions: activeSubscriptions,
        cancelledSubscriptions: cancelledSubscriptions,
        churnRate: totalCustomers > 0 ? Math.round((cancelledSubscriptions / totalCustomers) * 100) / 100 : 0,
        mrr: monthlyRevenue,
        totalCustomers: totalCustomers
      },
      trends: {
        revenue: revenueTrends,
        timeframe: timeframe
      },
      breakdown: {
        byPlan: {
          'Basic': planRevenue.basic,
          'Pro': planRevenue.pro,
          'Enterprise': planRevenue.enterprise
        },
        topCustomers: [] // Could be enhanced with real customer data
      },
      recentSubscriptions: (subscriptions || [])
        .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
        .slice(0, 5)
        .map(sub => ({
          id: sub.id,
          customerName: 'Customer', // Could get from profiles
          customerEmail: sub.email || 'N/A',
          planType: sub.subscription_plan,
          amount: revenuePerPlan[sub.subscription_plan] || 29,
          status: sub.subscription_status,
          createdAt: sub.created_at
        }))
    };

    return res.status(200).json({
      success: true,
      data: financialReport
    });

  } catch (error) {
    console.error('Financial endpoint error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to fetch financial data'
    });
  }
});

// Admin Financial Detailed Endpoint
app.get('/api/admin/financial-detailed', async (req, res) => {
  try {
    // Get Authorization header
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ success: false, error: 'No token provided' });
    }

    // Verify user and check admin role
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    
    if (authError || !user) {
      return res.status(401).json({ success: false, error: 'Invalid token' });
    }

    // Get user profile to check role
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (profileError || !profile || profile.role !== 'admin') {
      return res.status(403).json({ success: false, error: 'Admin access required' });
    }

    console.log('üí∞üìä Admin Detailed Financial report request from:', user.email);

    const { timeframe = '30d' } = req.query;
    
    // Calculate date range based on timeframe
    const now = new Date();
    let startDate = new Date(now);
    
    switch (timeframe) {
      case '7d':
        startDate.setDate(now.getDate() - 7);
        break;
      case '30d':
        startDate.setDate(now.getDate() - 30);
        break;
      case '90d':
        startDate.setDate(now.getDate() - 90);
        break;
      case '1y':
        startDate.setFullYear(now.getFullYear() - 1);
        break;
      default:
        startDate.setDate(now.getDate() - 30);
    }

    // Get all users with subscription data
    const { data: users, error: userError } = await supabase
      .from('users')
      .select('id, email, subscription_plan, subscription_status, created_at')
      .gte('created_at', startDate.toISOString());

    if (userError) {
      console.error('User query error:', userError);
    }

    // Get studies data for additional revenue insights
    const { data: studies, error: studyError } = await supabase
      .from('studies')
      .select('id, title, created_at, status')
      .gte('created_at', startDate.toISOString());

    if (studyError) {
      console.error('Study query error:', studyError);
    }

    // Revenue breakdown by plan
    const revenueByPlan = {
      basic: { price: 29, count: 0, revenue: 0 },
      pro: { price: 79, count: 0, revenue: 0 },
      enterprise: { price: 199, count: 0, revenue: 0 }
    };

    // Calculate revenue by subscription plan
    (users || []).forEach(user => {
      if (user.subscription_plan && user.subscription_status === 'active') {
        const plan = user.subscription_plan.toLowerCase();
        if (revenueByPlan[plan]) {
          revenueByPlan[plan].count++;
          revenueByPlan[plan].revenue += revenueByPlan[plan].price;
        }
      }
    });

    // Calculate daily revenue trend
    const dailyRevenue = [];
    const daysInPeriod = timeframe === '7d' ? 7 : timeframe === '30d' ? 30 : timeframe === '90d' ? 90 : 365;
    
    for (let i = daysInPeriod - 1; i >= 0; i--) {
      const day = new Date();
      day.setDate(day.getDate() - i);
      const dayStart = new Date(day.getFullYear(), day.getMonth(), day.getDate());
      const dayEnd = new Date(day.getFullYear(), day.getMonth(), day.getDate() + 1);
      
      const dayUsers = (users || []).filter(u => {
        const userDate = new Date(u.created_at);
        return userDate >= dayStart && userDate < dayEnd && u.subscription_status === 'active';
      });
      
      const dayRevenue = dayUsers.reduce((sum, user) => {
        const plan = user.subscription_plan?.toLowerCase();
        return sum + (revenueByPlan[plan]?.price || 0);
      }, 0);
      
      dailyRevenue.push({
        date: day.toISOString().split('T')[0],
        revenue: dayRevenue,
        subscribers: dayUsers.length
      });
    }

    // Customer acquisition cost and lifetime value (simplified calculations)
    const totalActiveUsers = (users || []).filter(u => u.subscription_status === 'active').length;
    const averageRevenue = Object.values(revenueByPlan).reduce((sum, plan) => sum + plan.revenue, 0) / Math.max(totalActiveUsers, 1);
    
    const detailedFinancial = {
      overview: {
        totalRevenue: Object.values(revenueByPlan).reduce((sum, plan) => sum + plan.revenue, 0),
        totalSubscribers: totalActiveUsers,
        averageRevenuePerUser: Math.round(averageRevenue * 100) / 100,
        customerLifetimeValue: Math.round(averageRevenue * 12), // Simplified: assume 12 month retention
      },
      revenueByPlan,
      dailyTrends: dailyRevenue,
      metrics: {
        churnRate: Math.round(((users || []).filter(u => u.subscription_status === 'cancelled').length / Math.max(totalActiveUsers, 1)) * 100 * 100) / 100,
        conversionRate: Math.round((totalActiveUsers / Math.max((users || []).length, 1)) * 100 * 100) / 100,
        monthlyGrowthRate: dailyRevenue.length > 30 ? 
          Math.round(((dailyRevenue.slice(-7).reduce((s, d) => s + d.subscribers, 0) - dailyRevenue.slice(-14, -7).reduce((s, d) => s + d.subscribers, 0)) / Math.max(dailyRevenue.slice(-14, -7).reduce((s, d) => s + d.subscribers, 0), 1)) * 100 * 100) / 100 : 0
      },
      studyMetrics: {
        totalStudies: (studies || []).length,
        activeStudies: (studies || []).filter(s => s.status === 'active').length,
        studyCreationTrend: (studies || []).length / daysInPeriod
      }
    };

    return res.status(200).json({ success: true, data: detailedFinancial });
  } catch (error) {
    console.error('Detailed financial data error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to fetch detailed financial data'
    });
  }
});

// Admin User Behavior Analytics Endpoint
app.get('/api/admin/user-behavior', async (req, res) => {
  try {
    // Get Authorization header
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ success: false, error: 'No token provided' });
    }

    // Verify user and check admin role
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    
    if (authError || !user) {
      return res.status(401).json({ success: false, error: 'Invalid token' });
    }

    // Get user profile to check role
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (profileError || !profile || profile.role !== 'admin') {
      return res.status(403).json({ success: false, error: 'Admin access required' });
    }

    console.log('üìä Admin User Behavior Analytics request from:', user.email);

    // Mock user behavior data
    const behaviorAnalytics = {
      userEngagement: Array.from({length: 30}, (_, i) => ({
        date: new Date(Date.now() - (29-i) * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        activeUsers: Math.floor(Math.random() * 50) + 10,
        sessionsPerUser: Math.round((Math.random() * 3 + 1) * 100) / 100
      })),
      featureUsage: {
        'Study Creation': 156,
        'Session Recording': 342,
        'User Management': 89,
        'Analytics Dashboard': 234,
        'Data Export': 67
      },
      deviceTypes: {
        'Desktop': 245,
        'Mobile': 89,
        'Tablet': 23
      },
      timeframe: req.query.timeframe || '30d'
    };

    return res.status(200).json({
      success: true,
      data: behaviorAnalytics
    });

  } catch (error) {
    console.error('User behavior analytics endpoint error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to fetch user behavior analytics'
    });
  }
});

// Dashboard Analytics Endpoint - For all authenticated users
app.get('/api/dashboard/analytics', async (req, res) => {
  try {
    // Get Authorization header
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ success: false, error: 'No token provided' });
    }

    // Verify user authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    
    if (authError || !user) {
      return res.status(401).json({ success: false, error: 'Invalid token' });
    }

    // Get user profile to determine role
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (profileError || !profile) {
      return res.status(404).json({ success: false, error: 'User profile not found' });
    }

    console.log('üìä Dashboard Analytics request from:', user.email, 'Role:', profile.role);

    // Get real data based on user role
    let dashboardData = {};

    if (profile.role === 'researcher' || profile.role === 'admin') {
      // For researchers and admins - show studies data
      const { data: allStudies, count: totalStudies } = await supabase
        .from('studies')
        .select('id, title, status, created_at, target_participants', { count: 'exact' })
        .eq('researcher_id', user.id); // Only their studies for researchers

      // For admins, get all studies
      if (profile.role === 'admin') {
        const { data: adminStudies, count: adminStudyCount } = await supabase
          .from('studies')
          .select('id, title, status, created_at, target_participants', { count: 'exact' });
        
        dashboardData.totalStudies = adminStudyCount || 0;
        dashboardData.allStudies = adminStudies || [];
      } else {
        dashboardData.totalStudies = totalStudies || 0;
        dashboardData.allStudies = allStudies || [];
      }

      // Calculate active participants (sum of target_participants for active studies)
      const activeStudies = (dashboardData.allStudies || []).filter(study => study.status === 'active');
      const activeParticipants = activeStudies.reduce((sum, study) => sum + (study.target_participants || 0), 0);

      // Calculate completion rate (mock for now - would need sessions/responses table)
      const completionRate = activeStudies.length > 0 ? Math.round(Math.random() * 20 + 75) : 0;

      // Calculate average session time (mock for now)
      const avgSessionTime = activeStudies.length > 0 ? Math.round(Math.random() * 10 + 20) : 0;

      dashboardData = {
        ...dashboardData,
        activeParticipants,
        completionRate,
        avgSessionTime,
        activeStudies: activeStudies.length,
        recentStudies: (dashboardData.allStudies || [])
          .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
          .slice(0, 3)
          .map(study => ({
            id: study.id,
            title: study.title,
            status: study.status,
            participants: study.target_participants || 0,
            completionRate: Math.round(Math.random() * 30 + 70), // Mock completion rate
            lastUpdate: study.created_at
          }))
      };

    } else if (profile.role === 'participant') {
      // For participants - show participation data
      dashboardData = {
        totalStudies: 0, // Studies they've participated in
        activeParticipants: 1, // They are a participant
        completionRate: 0, // Their completion rate
        avgSessionTime: 0, // Their average session time
        activeStudies: 0,
        recentStudies: []
      };
    }

    return res.status(200).json({
      success: true,
      data: dashboardData
    });

  } catch (error) {
    console.error('Dashboard analytics error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to fetch dashboard analytics'
    });
  }
});

// Admin System Performance Endpoint
app.get('/api/admin/system-performance', async (req, res) => {
  try {
    // Get Authorization header
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ success: false, error: 'No token provided' });
    }

    // Verify user and check admin role
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    
    if (authError || !user) {
      return res.status(401).json({ success: false, error: 'Invalid token' });
    }

    // Get user profile to check role
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (profileError || !profile || profile.role !== 'admin') {
      return res.status(403).json({ success: false, error: 'Admin access required' });
    }

    console.log('‚ö°üìä Admin System Performance request from:', user.email);

    const { timeframe = '24h' } = req.query;
    
    // Calculate date range based on timeframe
    const now = new Date();
    let startDate = new Date(now);
    
    switch (timeframe) {
      case '1h':
        startDate.setHours(now.getHours() - 1);
        break;
      case '24h':
        startDate.setDate(now.getDate() - 1);
        break;
      case '7d':
        startDate.setDate(now.getDate() - 7);
        break;
      case '30d':
        startDate.setDate(now.getDate() - 30);
        break;
      default:
        startDate.setDate(now.getDate() - 1);
    }

    // Get database activity metrics (same logic as API)
    const { data: recentUsers, error: userError } = await supabase
      .from('users')
      .select('id, created_at, last_sign_in_at')
      .gte('created_at', startDate.toISOString())
      .limit(1000);

    if (userError) {
      console.error('User activity query error:', userError);
    }

    // Get study activity
    const { data: recentStudies, error: studyError } = await supabase
      .from('studies')
      .select('id, created_at, status')
      .gte('created_at', startDate.toISOString())
      .limit(1000);

    if (studyError) {
      console.error('Study activity query error:', studyError);
    }

    // Calculate system metrics based on database activity
    const systemMetrics = [
     
      {
        id: 'cpu',
        name: 'CPU Usage',
        value: performanceData.length > 0 ? performanceData[performanceData.length - 1].cpu : 45,
        unit: '%',
        change: performanceData.length > 1 ? 
          performanceData[performanceData.length - 1].cpu - performanceData[performanceData.length - 2].cpu : 0,
        status: performanceData.length > 0 && performanceData[performanceData.length - 1].cpu > 80 ? 'warning' : 'healthy'
      },
      {
        id: 'memory',
        name: 'Memory Usage',
        value: performanceData.length > 0 ? performanceData[performanceData.length - 1].memory : 62,
        unit: '%',
        change: performanceData.length > 1 ? 
          performanceData[performanceData.length - 1].memory - performanceData[performanceData.length - 2].memory : 0,
        status: performanceData.length > 0 && performanceData[performanceData.length - 1].memory > 85 ? 'warning' : 'healthy'
      },
      {
        id: 'response_time',
        name: 'Response Time',
        value: performanceData.length > 0 ? performanceData[performanceData.length - 1].responseTime : 145,
        unit: 'ms',
        change: performanceData.length > 1 ? 
          performanceData[performanceData.length - 2].responseTime - performanceData[performanceData.length - 1].responseTime : 0,
        status: performanceData.length > 0 && performanceData[performanceData.length - 1].responseTime > 300 ? 'warning' : 'healthy'
      },
      {
        id: 'active_users',
        name: 'Active Users',
        value: activeUsers,
        unit: '',
        change: totalUsers > activeUsers ? totalUsers - activeUsers : 0,
        status: 'healthy'
      }
    ];

    const usageStatistics = [
      {
        id: 'total_users',
        name: 'Total Users',
        value: totalUsers,
        unit: 'users',
        change: Math.round(Math.random() * 10) + 1,
        percentage: 100
      },
      {
        id: 'active_studies',
        id: 'active_studies',
        name: 'Active Studies',
        value: activeStudies,
        unit: 'studies',
        change: totalStudies - activeStudies,
        percentage: totalStudies > 0 ? Math.round((activeStudies / totalStudies) * 100) : 0
      },
      {
        id: 'api_requests',
        name: 'API Requests',
        value: Math.round(activeUsers * 50 + Math.random() * 500), // Estimate based on activity
        unit: 'requests',
        change: Math.round(Math.random() * 100),
        percentage: 100
      },
      {
        id: 'database_queries',
        name: 'Database Queries',
        value: Math.round(activeUsers * 25 + Math.random() * 200),
        unit: 'queries',
        change: Math.round(Math.random() * 50),
        percentage: 100
      }
    ];

    const systemPerformanceData = {
      metrics: systemMetrics,
      performanceData: performanceData,
      usageStatistics: usageStatistics,
      timeframe: timeframe,
      lastUpdated: now.toISOString()
    };

    return res.status(200).json({ success: true, data: systemPerformanceData });
  } catch (error) {
    console.error('System performance data error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to fetch system performance data'
    });
  }
});

// Consolidated Applications endpoints (NEW - supports all application operations)
app.all('/api/applications*', async (req, res) => {
  console.log('üîç Applications API request received:', {
    method: req.method,
    url: req.url,
    query: req.query,
    hasAuth: !!req.headers.authorization,
    timestamp: new Date().toISOString()
  });
  
  try {
    // Import the consolidated applications handler
    const applicationsModule = await import('../../api/applications.js');
    const handler = applicationsModule.default;
    
    await handler(req, res);
  } catch (error) {
    console.error('‚ùå Consolidated Applications API Error:', error);
    res.status(500).json({
      success: false,
      error: 'Applications operation failed',
      details: error.message
    });
  }
});

// ============ PAYMENT MANAGEMENT ENDPOINTS ============

// Payment Management API with Real Money Integration
app.all('/api/payments*', async (req, res) => {
  try {
    console.log(`üí≥ Payments API Request: ${req.method} ${req.url}`);
    
    // Import the enhanced payments handler
    const paymentsModule = await import('./api/payments.js');
    const handler = paymentsModule.default;
    
    // Call the handler with req and res
    await handler(req, res);
  } catch (error) {
    console.error('‚ùå Payments API Error:', error);
    res.status(500).json({
      success: false,
      error: 'Payment operation failed',
      message: error.message
    });
  }
});

// Points Management API (Production - Real Database)
app.all('/api/points*', async (req, res) => {
  try {
    console.log(`ü™ô Points API Request: ${req.method} ${req.url}`);
    
    // Import the production points handler (real database)
    const pointsModule = await import('../../api/points.js');
    const handler = pointsModule.default;
    
    // Call the handler with req and res
    await handler(req, res);
  } catch (error) {
    console.error('‚ùå Points API Error:', error);
    res.status(500).json({
      success: false,
      error: 'Points operation failed',
      message: error.message
    });
  }
>>>>>>> 0143a82207ffa6b8799d53ba39a6d3cfa1f2b452
});

// Frontend development server
function startFrontend() {
  return new Promise((resolve, reject) => {
    console.log('üöÄ Starting Vite frontend server...');
    
    const viteProcess = spawn('npm', ['run', 'dev'], {
      cwd: path.resolve(__dirname, '../..'),
      stdio: ['inherit', 'pipe', 'pipe'],
      shell: true
    });

    let serverStarted = false;

    viteProcess.stdout.on('data', (data) => {
      const output = data.toString();
      console.log(`üì± FRONTEND: ${output.trim()}`);
      
      if (output.includes('Local:') && !serverStarted) {
        serverStarted = true;
        resolve(viteProcess);
      }
    });

    viteProcess.stderr.on('data', (data) => {
      const error = data.toString();
      if (!error.includes('Warning') && !error.includes('DeprecationWarning')) {
        console.error(`‚ùå FRONTEND ERROR: ${error.trim()}`);
      }
    });

    viteProcess.on('close', (code) => {
      if (code !== 0 && !serverStarted) {
        reject(new Error(`Frontend server failed to start with code ${code}`));
      }
    });

    // Timeout fallback
    setTimeout(() => {
      if (!serverStarted) {
        resolve(viteProcess);
      }
    }, 10000);
  });
}

// Start servers
async function startServers() {
  try {
    console.log('üåü Starting ResearchHub Full Development Environment...\n');

    // Start backend
    const backendServer = app.listen(API_PORT, () => {
      console.log(`üîß Backend API server running on http://localhost:${API_PORT}`);
      console.log(`üìä API endpoints available at http://localhost:${API_PORT}/api/*`);
      console.log(`üîç Test health: http://localhost:${API_PORT}/api/system-consolidated?action=health\n`);
    });

    // Start frontend
    await startFrontend();

    console.log('\n‚úÖ FULL DEVELOPMENT ENVIRONMENT READY!');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log(`üéØ Frontend: http://localhost:${FRONTEND_PORT}`);
    console.log(`üîß Backend:  http://localhost:${API_PORT}`);
    console.log('üîë Test Accounts:');
    Object.entries(TEST_ACCOUNTS).forEach(([role, account]) => {
      console.log(`   ${role.toUpperCase()}: ${account.email} / ${account.password}`);
    });
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üí° Both servers will restart automatically on file changes');
    console.log('üõë Press Ctrl+C to stop both servers\n');

    // Graceful shutdown
    process.on('SIGINT', () => {
      console.log('\nüõë Shutting down development servers...');
      backendServer.close();
      process.exit(0);
    });

  } catch (error) {
    console.error('‚ùå Failed to start development environment:', error);
    process.exit(1);
  }
}

// Start the development environment
startServers();
