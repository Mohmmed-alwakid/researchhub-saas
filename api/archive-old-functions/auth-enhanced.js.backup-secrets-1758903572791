import { createClient } from '@supabase/supabase-js';
import { ApiResponseHelper } from './services/ApiResponse.js';


/**
 * PHASE 2: AUTHENTICATION & AUTHORIZATION ENHANCEMENT
 * Enhanced authentication system with JWT validation and role-based access
 * Requirements Source: docs/requirements/02-AUTHENTICATION_AUTHORIZATION.md
 */

// Supabase configuration
const supabaseUrl = 'https://wxpwxzdgdvinlbtnbgdf.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind4cHd4emRnZHZpbmxidG5iZ2RmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAxOTk1ODAsImV4cCI6MjA2NTc3NTU4MH0.YMai9p4VQMbdqmc_9uWGeJ6nONHwuM9XT2FDTFy0aGk';
const supabaseServiceKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind4cHd4emRnZHZpbmxidG5iZ2RmIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1MDE5OTU4MCwiZXhwIjoyMDY1Nzc1NTgwfQ.hM5DhDshOQOhXIepbPWiznEDgpN9MzGhB0kzlxGd_6Y';

const supabase = createClient(supabaseUrl, supabaseKey);
const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey);

// Test accounts for development (from TESTING_RULES_MANDATORY.md)
const TEST_ACCOUNTS = {
  participant: {
    email: 'abwanwr77+participant@gmail.com',
    password: 'Testtest123',
    role: 'participant'
  },
  researcher: {
    email: 'abwanwr77+Researcher@gmail.com',
    password: 'Testtest123',
    role: 'researcher'
  },
  admin: {
    email: 'abwanwr77+admin@gmail.com',
    password: 'Testtest123',
    role: 'admin'
  }
};

/**
 * Enhanced Authentication API Handler
 */
export default async function handler(req, res) {
  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.setHeader('Access-Control-Allow-Credentials', 'true');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  const startTime = Date.now();
  const { action } = req.query;

  try {
    switch (action) {
      case 'login':
        return await handleLogin(req, res, startTime);
      
      case 'register':
        return await handleRegister(req, res, startTime);
      
      case 'refresh':
        return await handleRefreshToken(req, res, startTime);
      
      case 'logout':
        return await handleLogout(req, res, startTime);
      
      case 'verify':
        return await handleVerifyToken(req, res, startTime);
      
      case 'profile':
        return await handleGetProfile(req, res, startTime);
      
      case 'update-profile':
        return await handleUpdateProfile(req, res, startTime);
        
      case 'test-accounts':
        return await handleTestAccounts(req, res, startTime);
        
      default:
        return res.status(400).json({
          success: false,
          error: 'INVALID_ACTION',
          message: `Unknown action: ${action}`,
          meta: {
            validActions: ['login', 'register', 'refresh', 'logout', 'verify', 'profile', 'update-profile', 'test-accounts'],
            processingTime: Date.now() - startTime
          }
        });
    }
  } catch (error) {
    console.error('Auth API error:', error);
    return res.status(500).json({
      success: false,
      error: 'INTERNAL_SERVER_ERROR',
      message: process.env.NODE_ENV === 'development' ? error.message : 'Authentication service error',
      meta: {
        processingTime: Date.now() - startTime,
        timestamp: new Date().toISOString()
      }
    });
  }
}

/**
 * Handle user login with enhanced validation
 */
async function handleLogin(req, res, startTime) {
  if (req.method !== 'POST') {
    return res.status(405).json(ApiResponseHelper.error('METHOD_NOT_ALLOWED', 'POST method required'));
  }

  const { email, password, rememberMe } = req.body;

  // Validation
  if (!email || !password) {
    return res.status(400).json(ApiResponseHelper.validationError({
      missingFields: !email ? ['email'] : ['password']
    }));
  }

  try {
    // Check if it's a test account first
    const testAccount = Object.values(TEST_ACCOUNTS).find(account => 
      account.email.toLowerCase() === email.toLowerCase() && account.password === password
    );

    if (testAccount) {
      // Generate mock JWT for test account
      const mockUser = {
        id: `test-${testAccount.role}-${Date.now()}`,
        email: testAccount.email,
        role: testAccount.role,
        email_verified: true,
        created_at: new Date().toISOString()
      };

      const mockSession = {
        access_token: generateMockJWT(mockUser),
        refresh_token: `refresh_${mockUser.id}`,
        expires_in: rememberMe ? 604800 : 3600, // 7 days or 1 hour
        expires_at: Date.now() + (rememberMe ? 604800000 : 3600000)
      };

      return res.status(200).json({
        success: true,
        data: {
          user: mockUser,
          session: mockSession
        },
        message: `Test account login successful (${testAccount.role})`,
        meta: {
          processingTime: Date.now() - startTime,
          testAccount: true,
          accountType: testAccount.role
        }
      });
    }

    // Attempt Supabase authentication for real accounts
    const { data, error } = await supabase.auth.signInWithPassword({
      email: email.toLowerCase().trim(),
      password
    });

    if (error) {
      return res.status(401).json(ApiResponseHelper.error(
        'AUTHENTICATION_FAILED',
        'Invalid email or password'
      ));
    }

    // Successful Supabase login
    const { user, session } = data;

    // Try to get user profile and role (with error handling)
    let userProfile = null;
    try {
      const { data: profileData } = await supabaseAdmin
        .from('users')
        .select('role, profile_completed, first_name, last_name')
        .eq('id', user.id)
        .single();
      userProfile = profileData;

      // Update last login if table exists
      await supabaseAdmin
        .from('users')
        .update({ 
          last_active: new Date().toISOString()
        })
        .eq('id', user.id);
    } catch (profileError) {
      console.log('Profile lookup failed (table may not exist yet):', profileError.message);
    }

    // Enhanced user object
    const enhancedUser = {
      ...user,
      role: userProfile?.role || 'participant',
      profile_completed: userProfile?.profile_completed || false,
      first_name: userProfile?.first_name,
      last_name: userProfile?.last_name
    };

    return res.status(200).json({
      success: true,
      data: {
        user: enhancedUser,
        session
      },
      message: 'Login successful',
      meta: {
        processingTime: Date.now() - startTime,
        testAccount: false,
        requiresProfileCompletion: !userProfile?.profile_completed
      }
    });

  } catch (error) {
    console.error('Login error:', error);
    return res.status(500).json(ApiResponseHelper.serverError('Login service unavailable'));
  }
}

/**
 * Handle user registration with role assignment
 */
async function handleRegister(req, res, startTime) {
  if (req.method !== 'POST') {
    return res.status(405).json(ApiResponseHelper.error('METHOD_NOT_ALLOWED', 'POST method required'));
  }

  const { email, password, firstName, lastName, role = 'participant', organizationCode } = req.body;

  // Validation
  const missingFields = [];
  if (!email) missingFields.push('email');
  if (!password) missingFields.push('password');
  if (!firstName) missingFields.push('firstName');

  if (missingFields.length > 0) {
    return res.status(400).json(ApiResponseHelper.validationError({ missingFields }));
  }

  // Password strength validation
  if (password.length < 8) {
    return res.status(400).json(ApiResponseHelper.validationError({
      password: 'Password must be at least 8 characters long'
    }));
  }

  try {
    // Check if email already exists
    const { data: existingUser } = await supabase.auth.signInWithPassword({
      email: email.toLowerCase().trim(),
      password: 'dummy-check'
    });

    if (existingUser) {
      return res.status(409).json(ApiResponseHelper.error(
        'EMAIL_EXISTS',
        'An account with this email already exists'
      ));
    }

    // Create user account
    const { data, error } = await supabase.auth.signUp({
      email: email.toLowerCase().trim(),
      password,
      options: {
        data: {
          first_name: firstName,
          last_name: lastName,
          role: role
        }
      }
    });

    if (error) {
      return res.status(400).json(ApiResponseHelper.error(
        'REGISTRATION_FAILED',
        error.message
      ));
    }

    const { user, session } = data;

    // Create user profile record
    if (user) {
      await supabaseAdmin
        .from('users')
        .insert({
          id: user.id,
          email: user.email,
          role: role,
          profile_completed: !!(firstName && lastName),
          created_at: new Date().toISOString(),
          email_verified: false
        });

      // Create user profile
      await supabaseAdmin
        .from('user_profiles')
        .insert({
          user_id: user.id,
          first_name: firstName,
          last_name: lastName,
          created_at: new Date().toISOString()
        });

      // Handle organization membership
      if (organizationCode && role === 'researcher') {
        const { data: organization } = await supabaseAdmin
          .from('organizations')
          .select('id')
          .eq('invite_code', organizationCode)
          .single();

        if (organization) {
          await supabaseAdmin
            .from('organization_memberships')
            .insert({
              organization_id: organization.id,
              user_id: user.id,
              role: 'member',
              joined_at: new Date().toISOString()
            });
        }
      }
    }

    return res.status(201).json({
      success: true,
      data: {
        user: {
          ...user,
          role,
          profile_completed: !!(firstName && lastName),
          first_name: firstName,
          last_name: lastName
        },
        session
      },
      message: 'Registration successful. Please check your email for verification.',
      meta: {
        processingTime: Date.now() - startTime,
        emailVerificationRequired: true
      }
    });

  } catch (error) {
    console.error('Registration error:', error);
    return res.status(500).json(ApiResponseHelper.serverError('Registration service unavailable'));
  }
}

/**
 * Handle token refresh
 */
async function handleRefreshToken(req, res, startTime) {
  const { refresh_token } = req.body;

  if (!refresh_token) {
    return res.status(400).json(ApiResponseHelper.validationError({
      missingFields: ['refresh_token']
    }));
  }

  try {
    const { data, error } = await supabase.auth.refreshSession({
      refresh_token
    });

    if (error) {
      return res.status(401).json(ApiResponseHelper.error(
        'TOKEN_REFRESH_FAILED',
        'Invalid or expired refresh token'
      ));
    }

    return res.status(200).json({
      success: true,
      data: data,
      message: 'Token refreshed successfully',
      meta: {
        processingTime: Date.now() - startTime
      }
    });

  } catch (error) {
    console.error('Token refresh error:', error);
    return res.status(500).json(ApiResponseHelper.serverError('Token refresh service unavailable'));
  }
}

/**
 * Handle user logout
 */
async function handleLogout(req, res, startTime) {
  try {
    await supabase.auth.signOut();

    return res.status(200).json({
      success: true,
      data: null,
      message: 'Logout successful',
      meta: {
        processingTime: Date.now() - startTime
      }
    });

  } catch (error) {
    console.error('Logout error:', error);
    return res.status(500).json(ApiResponseHelper.serverError('Logout service unavailable'));
  }
}

/**
 * Handle token verification
 */
async function handleVerifyToken(req, res, startTime) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json(ApiResponseHelper.authError());
  }

  const token = authHeader.substring(7);

  try {
    const { data, error } = await supabase.auth.getUser(token);

    if (error || !data.user) {
      return res.status(401).json(ApiResponseHelper.error(
        'TOKEN_INVALID',
        'Invalid or expired token'
      ));
    }

    return res.status(200).json({
      success: true,
      data: {
        user: data.user,
        valid: true
      },
      message: 'Token is valid',
      meta: {
        processingTime: Date.now() - startTime
      }
    });

  } catch (error) {
    console.error('Token verification error:', error);
    return res.status(500).json(ApiResponseHelper.serverError('Token verification service unavailable'));
  }
}

/**
 * Handle get user profile
 */
async function handleGetProfile(req, res, startTime) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json(ApiResponseHelper.authError());
  }

  const token = authHeader.substring(7);

  try {
    const { data, error } = await supabase.auth.getUser(token);

    if (error || !data.user) {
      return res.status(401).json(ApiResponseHelper.authError());
    }

    // Get enhanced profile
    const { data: userProfile } = await supabaseAdmin
      .from('users')
      .select(`
        *,
        user_profiles (*)
      `)
      .eq('id', data.user.id)
      .single();

    return res.status(200).json({
      success: true,
      data: userProfile,
      message: 'Profile retrieved successfully',
      meta: {
        processingTime: Date.now() - startTime
      }
    });

  } catch (error) {
    console.error('Get profile error:', error);
    return res.status(500).json(ApiResponseHelper.serverError('Profile service unavailable'));
  }
}

/**
 * Handle profile updates
 */
async function handleUpdateProfile(req, res, startTime) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json(ApiResponseHelper.authError());
  }

  const token = authHeader.substring(7);
  const profileData = req.body;

  try {
    const { data, error } = await supabase.auth.getUser(token);

    if (error || !data.user) {
      return res.status(401).json(ApiResponseHelper.authError());
    }

    // Update user profile
    const { data: updatedProfile, error: updateError } = await supabaseAdmin
      .from('user_profiles')
      .upsert({
        user_id: data.user.id,
        ...profileData,
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (updateError) {
      return res.status(400).json(ApiResponseHelper.error(
        'PROFILE_UPDATE_FAILED',
        updateError.message
      ));
    }

    // Mark profile as completed if key fields are present
    if (profileData.first_name) {
      await supabaseAdmin
        .from('users')
        .update({ profile_completed: true })
        .eq('id', data.user.id);
    }

    return res.status(200).json({
      success: true,
      data: updatedProfile,
      message: 'Profile updated successfully',
      meta: {
        processingTime: Date.now() - startTime
      }
    });

  } catch (error) {
    console.error('Update profile error:', error);
    return res.status(500).json(ApiResponseHelper.serverError('Profile update service unavailable'));
  }
}

/**
 * Handle test accounts (development only)
 */
async function handleTestAccounts(req, res, startTime) {
  if (process.env.NODE_ENV === 'production') {
    return res.status(404).json(ApiResponseHelper.notFoundError('Endpoint'));
  }

  return res.status(200).json({
    success: true,
    data: {
      accounts: TEST_ACCOUNTS,
      usage: 'Use these accounts for testing. All have password: Testtest123'
    },
    message: 'Test accounts retrieved successfully',
    meta: {
      processingTime: Date.now() - startTime,
      environment: 'development'
    }
  });
}

/**
 * Generate mock JWT for test accounts
 */
function generateMockJWT(user) {
  return `mock_jwt_${user.role}_${user.id}_${Date.now()}`;
}

/**
 * Middleware: Validate JWT token
 */
export async function validateJWTToken(req) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return { success: false, error: 'No token provided' };
  }

  const token = authHeader.substring(7);

  // Check for mock JWT (development)
  if (token.startsWith('mock_jwt_')) {
    const parts = token.split('_');
    return {
      success: true,
      user: {
        id: parts[3],
        role: parts[2],
        email: `test-${parts[2]}@example.com`
      }
    };
  }

  try {
    const { data, error } = await supabase.auth.getUser(token);

    if (error || !data.user) {
      return { success: false, error: 'Invalid token' };
    }

    return { success: true, user: data.user };
  } catch (error) {
    return { success: false, error: 'Token validation failed' };
  }
}

/**
 * Middleware: Check user role permissions
 */
export function checkRolePermission(userRole, requiredRoles) {
  if (!Array.isArray(requiredRoles)) {
    requiredRoles = [requiredRoles];
  }

  // Admin has access to everything
  if (userRole === 'admin') {
    return true;
  }

  return requiredRoles.includes(userRole);
}

export {
  handleLogin,
  handleRegister,
  handleRefreshToken,
  handleLogout,
  handleVerifyToken,
  handleGetProfile,
  handleUpdateProfile,
  handleTestAccounts
};
