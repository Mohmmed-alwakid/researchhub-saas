import { createClient } from '@supabase/supabase-js';


/**
 * Study Sessions API Endpoint - ResearchHub SaaS Platform
 * 
 * Handles participant study session operations with secure authentication
 * Supports: Session creation, progress tracking, completion, data retrieval
 * 
 * Endpoints:
 * - POST /api/study-sessions - Create new study session
 * - GET /api/study-sessions/:id - Get specific session
 * - PUT /api/study-sessions/progress - Update session progress
 * - PUT /api/study-sessions/:id/complete - Complete session
 * - GET /api/study-sessions/my-sessions - Get user's sessions
 * - GET /api/study-sessions?studyId=:id - Get sessions for study (researcher)
 * 
 * Security Features:
 * - JWT token authentication
 * - Row Level Security (RLS) enforcement  
 * - Participant/researcher role-based access
 * - Comprehensive error handling and logging
 * 
 * Created: July 10, 2025
 * Status: Production Ready ‚úÖ
 */

const supabaseUrl = 'https://wxpwxzdgdvinlbtnbgdf.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind4cHd4emRnZHZpbmxidG5iZ2RmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAxOTk1ODAsImV4cCI6MjA2NTc3NTU4MH0.YMai9p4VQMbdqmc_9uWGeJ6nONHwuM9XT2FDTFy0aGk';
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

export default async function handler(req, res) {
  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  // Authentication setup
  const authHeader = req.headers.authorization;
  let currentUser = null;
  let supabase = createClient(supabaseUrl, supabaseKey);
  
  console.log('üéØ Study Sessions API Request:', {
    method: req.method,
    url: req.url,
    hasAuth: !!authHeader,
    timestamp: new Date().toISOString()
  });

  // Authentication validation
  if (!authHeader) {
    console.log('‚ùå Missing authorization header');
    return res.status(401).json({
      success: false,
      error: 'Authorization header required'
    });
  }

  try {
    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    
    if (authError || !user) {
      console.log('‚ùå Invalid token:', authError?.message);
      return res.status(401).json({
        success: false,
        error: 'Invalid or expired token'
      });
    }

    currentUser = user;
    console.log('‚úÖ Authenticated user:', { id: user.id, email: user.email });

  } catch (error) {
    console.error('‚ùå Authentication error:', error);
    return res.status(401).json({
      success: false,
      error: 'Authentication failed'
    });
  }

  try {
    // Route to appropriate handler based on method and path
    const url = new URL(req.url, `http://${req.headers.host}`);
    const pathSegments = url.pathname.split('/').filter(Boolean);
    const sessionId = pathSegments[2]; // /api/study-sessions/:id
    const action = pathSegments[3]; // /api/study-sessions/:id/:action
    const queryParams = Object.fromEntries(url.searchParams);

    switch (req.method) {
      case 'POST':
        if (url.pathname === '/api/study-sessions') {
          return await createStudySession(req, res, supabase, currentUser);
        }
        break;

      case 'GET':
        if (sessionId && !action) {
          return await getStudySession(req, res, supabase, currentUser, sessionId);
        } else if (url.pathname.includes('/my-sessions')) {
          return await getUserSessions(req, res, supabase, currentUser);
        } else if (queryParams.studyId) {
          return await getStudySessions(req, res, supabase, currentUser, queryParams);
        }
        break;

      case 'PUT':
        if (url.pathname.includes('/progress')) {
          return await updateSessionProgress(req, res, supabase, currentUser);
        } else if (sessionId && action === 'complete') {
          return await completeSession(req, res, supabase, currentUser, sessionId);
        }
        break;

      default:
        return res.status(405).json({
          success: false,
          error: `Method ${req.method} not allowed`
        });
    }

    return res.status(404).json({
      success: false,
      error: 'Endpoint not found'
    });

  } catch (error) {
    console.error('‚ùå Study Sessions API Error:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error',
      details: error.message
    });
  }
}

// Create new study session
async function createStudySession(req, res, supabase, currentUser) {
  try {
    const { studyId, recordingEnabled = false } = req.body;

    if (!studyId) {
      return res.status(400).json({
        success: false,
        error: 'Study ID is required'
      });
    }

    // Get study details
    const { data: study, error: studyError } = await supabase
      .from('studies')
      .select('*')
      .eq('_id', studyId)
      .single();

    if (studyError || !study) {
      return res.status(404).json({
        success: false,
        error: 'Study not found'
      });
    }

    // Create session record
    const sessionData = {
      id: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      study_id: studyId,
      participant_id: currentUser.id,
      status: 'active',
      started_at: new Date().toISOString(),
      recording_enabled: recordingEnabled,
      current_block_index: 0,
      completed_blocks: [],
      session_data: {},
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    const { data: session, error: sessionError } = await supabase
      .from('study_sessions')
      .insert(sessionData)
      .select()
      .single();

    if (sessionError) {
      console.error('Error creating session:', sessionError);
      return res.status(500).json({
        success: false,
        error: 'Failed to create session'
      });
    }

    console.log('‚úÖ Study session created:', session.id);

    return res.status(201).json({
      success: true,
      session: {
        ...session,
        study
      }
    });

  } catch (error) {
    console.error('Error in createStudySession:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to create study session'
    });
  }
}

// Get specific study session
async function getStudySession(req, res, supabase, currentUser, sessionId) {
  try {
    const { data: session, error: sessionError } = await supabase
      .from('study_sessions')
      .select(`
        *,
        study:studies!study_sessions_study_id_fkey(*)
      `)
      .eq('id', sessionId)
      .single();

    if (sessionError || !session) {
      return res.status(404).json({
        success: false,
        error: 'Session not found'
      });
    }

    // Check access permissions
    if (session.participant_id !== currentUser.id) {
      // Check if user is researcher of the study
      const { data: user, error: userError } = await supabase
        .from('users')
        .select('role')
        .eq('id', currentUser.id)
        .single();

      if (userError || !user || (user.role !== 'researcher' && user.role !== 'admin')) {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        });
      }
    }

    console.log('‚úÖ Session retrieved:', sessionId);

    return res.status(200).json({
      success: true,
      session
    });

  } catch (error) {
    console.error('Error in getStudySession:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to get session'
    });
  }
}

// Update session progress
async function updateSessionProgress(req, res, supabase, currentUser) {
  try {
    const { 
      sessionId, 
      currentBlockIndex, 
      completedBlocks, 
      sessionState,
      blockResponses 
    } = req.body;

    if (!sessionId) {
      return res.status(400).json({
        success: false,
        error: 'Session ID is required'
      });
    }

    const updateData = {
      current_block_index: currentBlockIndex,
      completed_blocks: completedBlocks,
      session_data: {
        sessionState,
        blockResponses,
        lastSaveTime: new Date().toISOString()
      },
      updated_at: new Date().toISOString()
    };

    const { data: session, error: updateError } = await supabase
      .from('study_sessions')
      .update(updateData)
      .eq('id', sessionId)
      .eq('participant_id', currentUser.id)
      .select()
      .single();

    if (updateError) {
      console.error('Error updating session progress:', updateError);
      return res.status(500).json({
        success: false,
        error: 'Failed to update progress'
      });
    }

    console.log('‚úÖ Session progress updated:', sessionId);

    return res.status(200).json({
      success: true,
      session
    });

  } catch (error) {
    console.error('Error in updateSessionProgress:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to update session progress'
    });
  }
}

// Complete study session
async function completeSession(req, res, supabase, currentUser, sessionId) {
  try {
    const { finalResponses, completionData } = req.body;

    const updateData = {
      status: 'completed',
      completed_at: new Date().toISOString(),
      session_data: {
        finalResponses,
        completionData,
        completedAt: new Date().toISOString()
      },
      updated_at: new Date().toISOString()
    };

    const { data: session, error: updateError } = await supabase
      .from('study_sessions')
      .update(updateData)
      .eq('id', sessionId)
      .eq('participant_id', currentUser.id)
      .select()
      .single();

    if (updateError) {
      console.error('Error completing session:', updateError);
      return res.status(500).json({
        success: false,
        error: 'Failed to complete session'
      });
    }

    console.log('‚úÖ Session completed:', sessionId);

    return res.status(200).json({
      success: true,
      session
    });

  } catch (error) {
    console.error('Error in completeSession:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to complete session'
    });
  }
}

// Get user's sessions
async function getUserSessions(req, res, supabase, currentUser) {
  try {
    const { data: sessions, error: sessionsError } = await supabase
      .from('study_sessions')
      .select(`
        *,
        study:studies!study_sessions_study_id_fkey(title, description, type)
      `)
      .eq('participant_id', currentUser.id)
      .order('created_at', { ascending: false });

    if (sessionsError) {
      console.error('Error getting user sessions:', sessionsError);
      return res.status(500).json({
        success: false,
        error: 'Failed to get sessions'
      });
    }

    console.log('‚úÖ User sessions retrieved:', sessions.length);

    return res.status(200).json({
      success: true,
      sessions
    });

  } catch (error) {
    console.error('Error in getUserSessions:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to get user sessions'
    });
  }
}

// Get sessions for a study (researcher view)
async function getStudySessions(req, res, supabase, currentUser, queryParams) {
  try {
    const { studyId, export: exportFormat } = queryParams;

    if (!studyId) {
      return res.status(400).json({
        success: false,
        error: 'Study ID is required'
      });
    }

    // Verify user is researcher/admin
    const { data: user, error: userError } = await supabase
      .from('users')
      .select('role')
      .eq('id', currentUser.id)
      .single();

    if (userError || !user || (user.role !== 'researcher' && user.role !== 'admin')) {
      return res.status(403).json({
        success: false,
        error: 'Access denied'
      });
    }

    const { data: sessions, error: sessionsError } = await supabase
      .from('study_sessions')
      .select(`
        *,
        participant:users!study_sessions_participant_id_fkey(email, user_metadata)
      `)
      .eq('study_id', studyId)
      .order('created_at', { ascending: false });

    if (sessionsError) {
      console.error('Error getting study sessions:', sessionsError);
      return res.status(500).json({
        success: false,
        error: 'Failed to get study sessions'
      });
    }

    console.log('‚úÖ Study sessions retrieved:', sessions.length);

    return res.status(200).json({
      success: true,
      sessions
    });

  } catch (error) {
    console.error('Error in getStudySessions:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to get study sessions'
    });
  }
}