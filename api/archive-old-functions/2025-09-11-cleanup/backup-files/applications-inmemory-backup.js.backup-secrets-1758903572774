import { createClient } from '@supabase/supabase-js';


/**
 * APPLICATIONS API
 * Handles: Participant study applications
 */

// Supabase configuration
const supabaseUrl = process.env.SUPABASE_URL || 'https://wxpwxzdgdvinlbtnbgdf.supabase.co';
const supabaseKey = process.env.SUPABASE_ANON_KEY || 'process.env.SUPABASE_SERVICE_ROLE_KEY || 'your_supabase_service_role_key_here'';
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind4cHd4emRnZHZpbmxidG5iZ2RmIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1MDE5OTU4MCwiZXhwIjoyMDY1Nzc1NTgwfQ.I_4j2vgcu2aR9Pw1d-QG2hpKunbmNKD8tWg3Psl0GNc';

// Initialize Supabase clients
const supabase = createClient(supabaseUrl, supabaseKey);
const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey);

// In-memory storage for applications (replace with database in production)
let applicationsDatabase = [];
let applicationIdCounter = 1;

console.log('ðŸ“‹ Applications API initialized');

/**
 * Helper function to authenticate user
 */
async function authenticateUser(req) {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return { success: false, error: 'Missing or invalid authorization header', status: 401 };
    }

    const token = authHeader.replace('Bearer ', '');
    
    // Verify token with Supabase
    const { data: { user }, error } = await supabase.auth.getUser(token);

    if (error || !user) {
      console.log('âŒ Token verification failed:', error?.message);
      return { success: false, error: 'Invalid or expired token', status: 401 };
    }

    return {
      success: true,
      user: {
        id: user.id,
        email: user.email
      }
    };

  } catch (error) {
    console.error('Authentication error:', error);
    return { success: false, error: 'Authentication service error', status: 500 };
  }
}

/**
 * Main API handler
 */
export default async function handler(req, res) {
  // Set CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  try {
    const { endpoint, action } = req.query;

    console.log('ðŸ“‹ Applications API - Query params:', { endpoint, action, method: req.method });

    // Handle different endpoint patterns
    if (endpoint === 'applications/my-applications' || action === 'my-applications') {
      return await getMyApplications(req, res);
    } else if (endpoint && endpoint.includes('/withdraw')) {
      return await withdrawApplication(req, res);
    } else if (endpoint && endpoint.includes('/applications')) {
      return await getStudyApplications(req, res);
    } else if (action === 'apply' || req.method === 'POST') {
      return await submitApplication(req, res);
    } else {
      console.log('âŒ Applications API - Invalid parameters:', { endpoint, action });
      return res.status(400).json({ 
        success: false, 
        error: `Invalid endpoint or action parameter. Received: endpoint=${endpoint}, action=${action}` 
      });
    }

  } catch (error) {
    console.error('Applications API error:', error);
    return res.status(500).json({ 
      success: false, 
      error: 'Internal server error' 
    });
  }
}

/**
 * Get participant's applications
 */
async function getMyApplications(req, res) {
  const auth = await authenticateUser(req);
  if (!auth.success) {
    return res.status(auth.status).json(auth);
  }

  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const status = req.query.status;

    console.log('ðŸ“‹ Get my applications request:', { userId: auth.user.id, page, limit, status });

    // Filter applications by user ID
    let userApplications = applicationsDatabase.filter(app => 
      app.participant_id === auth.user.id
    );

    // Apply status filter if provided
    if (status && status !== 'all') {
      userApplications = userApplications.filter(app => app.status === status);
    }

    // Apply pagination
    const total = userApplications.length;
    const totalPages = Math.ceil(total / limit);
    const startIndex = (page - 1) * limit;
    const paginatedApplications = userApplications.slice(startIndex, startIndex + limit);

    console.log(`ðŸ“‹ Found ${total} applications for user ${auth.user.email}`);

    return res.status(200).json({ 
      success: true, 
      data: {
        applications: paginatedApplications,
        pagination: {
          current: page,
          pages: totalPages,
          total: total
        }
      }
    });

  } catch (error) {
    console.error('Get my applications error:', error);
    return res.status(500).json({ 
      success: false, 
      error: 'Failed to fetch applications' 
    });
  }
}

/**
 * Withdraw application
 */
async function withdrawApplication(req, res) {
  const auth = await authenticateUser(req);
  if (!auth.success) {
    return res.status(auth.status).json(auth);
  }

  try {
    const { endpoint } = req.query;
    const applicationId = endpoint.split('/')[1]; // Extract application ID

    // For now, return success response
    // In the future, this would update the application status
    return res.status(200).json({ 
      success: true, 
      message: 'Application withdrawn successfully' 
    });

  } catch (error) {
    console.error('Withdraw application error:', error);
    return res.status(500).json({ 
      success: false, 
      error: 'Failed to withdraw application' 
    });
  }
}

/**
 * Get study applications (for researchers)
 */
async function getStudyApplications(req, res) {
  const auth = await authenticateUser(req);
  if (!auth.success) {
    return res.status(auth.status).json(auth);
  }

  try {
    // For now, return empty applications list
    // In the future, this would fetch applications for the study
    const applications = [];

    return res.status(200).json({ 
      success: true, 
      data: {
        applications: applications,
        total: 0,
        page: parseInt(req.query.page) || 1,
        limit: parseInt(req.query.limit) || 10,
        totalPages: 0
      }
    });

  } catch (error) {
    console.error('Get study applications error:', error);
    return res.status(500).json({ 
      success: false, 
      error: 'Failed to fetch study applications' 
    });
  }
}

/**
 * Submit a study application
 */
async function submitApplication(req, res) {
  const auth = await authenticateUser(req);
  if (!auth.success) {
    return res.status(auth.status).json(auth);
  }

  try {
    const { studyId, responses, screeningResponses } = req.body;

    // Handle both possible field names for responses
    const finalResponses = responses || screeningResponses || [];

    console.log('ðŸ“‹ Submit application request:', { studyId, finalResponses, userId: auth.user.id });

    // Validate required studyId
    if (!studyId) {
      return res.status(400).json({
        success: false,
        error: 'studyId is required'
      });
    }

    // Check if user has already applied to this study
    const existingApplication = applicationsDatabase.find(app => 
      app.participant_id === auth.user.id && app.study_id === studyId
    );

    if (existingApplication) {
      return res.status(409).json({
        success: false,
        code: 'DUPLICATE_APPLICATION',
        error: 'You have already applied to this study'
      });
    }

    // Create and store the application
    const application = {
      id: applicationIdCounter++,
      _id: String(applicationIdCounter - 1),
      study_id: studyId,
      participant_id: auth.user.id,
      participant_email: auth.user.email,
      status: 'pending',
      responses: finalResponses,
      submitted_at: new Date().toISOString(),
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      // Frontend compatibility fields
      studyId: studyId,
      participantId: auth.user.id,
      appliedAt: new Date().toISOString(),
      reviewedAt: null,
      rejectionReason: null,
      notes: null,
      screeningResponses: finalResponses
    };

    // Store in memory database
    applicationsDatabase.push(application);
    
    console.log(`âœ… Application created: Study ${studyId} by ${auth.user.email} (ID: ${application.id})`);

    return res.status(201).json({ 
      success: true, 
      data: application,
      message: 'Application submitted successfully' 
    });

  } catch (error) {
    console.error('Submit application error:', error);
    return res.status(500).json({ 
      success: false, 
      error: 'Failed to submit application' 
    });
  }
}
