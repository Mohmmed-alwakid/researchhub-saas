import { createClient } from '@supabase/supabase-js';


/**
 * Simulated Wallets API - For testing without database tables
 * 
 * This version simulates the wallet system functionality using in-memory storage
 * to demonstrate the complete workflow without requiring database setup.
 * 
 * Created: July 5, 2025 - For workflow demonstration
 */

const supabaseUrl = 'https://wxpwxzdgdvinlbtnbgdf.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind4cHd4emRnZHZpbmxidG5iZ2RmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAxOTk1ODAsImV4cCI6MjA2NTc3NTU4MH0.YMai9p4VQMbdqmc_9uWGeJ6nONHwuM9XT2FDTFy0aGk';

// In-memory storage for demonstration
const simulatedData = {
  wallets: new Map(),
  withdrawals: new Map(),
  transactions: new Map()
};

function generateId() {
  return 'sim-' + Math.random().toString(36).substr(2, 9);
}

export default async function handler(req, res) {
  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  const { action } = req.query;

  // Create Supabase client for authentication
  const supabase = createClient(supabaseUrl, supabaseKey);

  try {
    switch (action) {
      case 'get':
        return await getParticipantWallet(req, res, supabase);
      case 'request-withdrawal':
        return await requestWithdrawal(req, res, supabase);
      case 'withdrawals':
        return await getParticipantWithdrawals(req, res, supabase);
      case 'transactions':
        return await getWalletTransactions(req, res, supabase);
      case 'admin-withdrawals':
        return await getAllWithdrawals(req, res, supabase);
      case 'process-withdrawal':
        return await processWithdrawal(req, res, supabase);
      case 'admin-wallets':
        return await getAllWallets(req, res, supabase);
      case 'add-earnings':
        return await addStudyEarnings(req, res, supabase);
      default:
        return res.status(400).json({
          success: false,
          error: 'Invalid action parameter'
        });
    }
  } catch (error) {
    console.error('Simulated Wallets API error:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
}

// Get participant wallet (simulated)
async function getParticipantWallet(req, res, supabase) {
  if (req.method !== 'GET') {
    return res.status(405).json({ success: false, error: 'Method not allowed' });
  }

  // Verify authentication
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ success: false, error: 'No authorization header' });
  }

  const token = authHeader.replace('Bearer ', '');
  const { data: { user }, error: authError } = await supabase.auth.getUser(token);
  
  if (authError || !user) {
    return res.status(401).json({ success: false, error: 'Invalid token' });
  }

  try {
    // Get or create simulated wallet
    let wallet = simulatedData.wallets.get(user.id);
    
    if (!wallet) {
      wallet = {
        id: generateId(),
        participant_id: user.id,
        balance: 0.00,
        total_earned: 0.00,
        total_withdrawn: 0.00,
        currency: 'USD',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      simulatedData.wallets.set(user.id, wallet);
    }

    return res.status(200).json({
      success: true,
      data: wallet
    });

  } catch (error) {
    console.error('Get simulated wallet error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to get wallet'
    });
  }
}

// Request withdrawal (simulated)
async function requestWithdrawal(req, res, supabase) {
  if (req.method !== 'POST') {
    return res.status(405).json({ success: false, error: 'Method not allowed' });
  }

  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ success: false, error: 'No authorization header' });
  }

  const token = authHeader.replace('Bearer ', '');
  const { data: { user }, error: authError } = await supabase.auth.getUser(token);
  
  if (authError || !user) {
    return res.status(401).json({ success: false, error: 'Invalid token' });
  }

  const { amount, payment_method, payment_details } = req.body;

  if (!amount || amount <= 0) {
    return res.status(400).json({
      success: false,
      error: 'Valid amount is required'
    });
  }

  try {
    // Get wallet
    const wallet = simulatedData.wallets.get(user.id);
    
    if (!wallet || wallet.balance < amount) {
      return res.status(400).json({
        success: false,
        error: 'Insufficient balance'
      });
    }

    // Create withdrawal request
    const withdrawal = {
      id: generateId(),
      participant_id: user.id,
      wallet_id: wallet.id,
      amount: amount,
      status: 'pending',
      payment_method: payment_method || 'paypal',
      payment_details: payment_details || {},
      admin_notes: null,
      requested_at: new Date().toISOString(),
      processed_at: null,
      processed_by: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    simulatedData.withdrawals.set(withdrawal.id, withdrawal);

    return res.status(200).json({
      success: true,
      data: withdrawal,
      message: 'Withdrawal request created successfully'
    });

  } catch (error) {
    console.error('Request withdrawal error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to create withdrawal request'
    });
  }
}

// Add earnings (simulated) - No authentication required (system call)
async function addStudyEarnings(req, res, supabase) {
  if (req.method !== 'POST') {
    return res.status(405).json({ success: false, error: 'Method not allowed' });
  }

  const { participant_id, amount, study_id, study_title } = req.body;

  console.log('🔍 Add earnings request:', { participant_id, amount, study_id, study_title });

  if (!participant_id || !amount || amount <= 0) {
    return res.status(400).json({
      success: false,
      error: 'Participant ID and positive amount are required'
    });
  }

  try {
    // Get or create wallet
    let wallet = simulatedData.wallets.get(participant_id);
    
    if (!wallet) {
      wallet = {
        id: generateId(),
        participant_id,
        balance: amount,
        total_earned: amount,
        total_withdrawn: 0.00,
        currency: 'USD',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
    } else {
      wallet.balance += amount;
      wallet.total_earned += amount;
      wallet.updated_at = new Date().toISOString();
    }

    simulatedData.wallets.set(participant_id, wallet);

    // Create transaction record
    const transaction = {
      id: generateId(),
      wallet_id: wallet.id,
      transaction_type: 'earning',
      amount: amount,
      balance_before: wallet.balance - amount,
      balance_after: wallet.balance,
      reference_type: 'study_completion',
      reference_id: study_id,
      description: study_title ? 
        `Study completion: ${study_title}` : 
        'Study completion reward',
      created_by: participant_id,
      created_at: new Date().toISOString()
    };

    simulatedData.transactions.set(transaction.id, transaction);

    console.log(`✅ Added $${amount} to participant ${participant_id} wallet. New balance: $${wallet.balance}`);

    return res.status(200).json({
      success: true,
      message: 'Earnings added successfully',
      data: {
        wallet,
        amount_added: amount,
        new_balance: wallet.balance
      }
    });

  } catch (error) {
    console.error('Add earnings error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to add earnings'
    });
  }
}

// Get participant withdrawals (simulated)
async function getParticipantWithdrawals(req, res, supabase) {
  if (req.method !== 'GET') {
    return res.status(405).json({ success: false, error: 'Method not allowed' });
  }

  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ success: false, error: 'No authorization header' });
  }

  const token = authHeader.replace('Bearer ', '');
  const { data: { user }, error: authError } = await supabase.auth.getUser(token);
  
  if (authError || !user) {
    return res.status(401).json({ success: false, error: 'Invalid token' });
  }

  try {
    const withdrawals = Array.from(simulatedData.withdrawals.values())
      .filter(w => w.participant_id === user.id)
      .sort((a, b) => new Date(b.requested_at) - new Date(a.requested_at));

    return res.status(200).json({
      success: true,
      data: withdrawals
    });

  } catch (error) {
    console.error('Get withdrawals error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to get withdrawals'
    });
  }
}

// Get wallet transactions (simulated)
async function getWalletTransactions(req, res, supabase) {
  if (req.method !== 'GET') {
    return res.status(405).json({ success: false, error: 'Method not allowed' });
  }

  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ success: false, error: 'No authorization header' });
  }

  const token = authHeader.replace('Bearer ', '');
  const { data: { user }, error: authError } = await supabase.auth.getUser(token);
  
  if (authError || !user) {
    return res.status(401).json({ success: false, error: 'Invalid token' });
  }

  try {
    const wallet = simulatedData.wallets.get(user.id);
    
    if (!wallet) {
      return res.status(200).json({
        success: true,
        data: []
      });
    }

    const transactions = Array.from(simulatedData.transactions.values())
      .filter(t => t.wallet_id === wallet.id)
      .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

    return res.status(200).json({
      success: true,
      data: transactions
    });

  } catch (error) {
    console.error('Get transactions error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to get transactions'
    });
  }
}

// Admin: Get all withdrawals (simulated)
async function getAllWithdrawals(req, res, supabase) {
  if (req.method !== 'GET') {
    return res.status(405).json({ success: false, error: 'Method not allowed' });
  }

  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ success: false, error: 'No authorization header' });
  }

  const token = authHeader.replace('Bearer ', '');
  const { data: { user }, error: authError } = await supabase.auth.getUser(token);
  
  if (authError || !user) {
    return res.status(401).json({ success: false, error: 'Invalid token' });
  }

  // Check if user is admin (simulated)
  if (!user.email.includes('admin')) {
    return res.status(403).json({ success: false, error: 'Admin access required' });
  }

  try {
    const withdrawals = Array.from(simulatedData.withdrawals.values())
      .map(w => ({
        ...w,
        participant: {
          name: 'Simulated Participant',
          email: 'participant@example.com'
        }
      }))
      .sort((a, b) => new Date(b.requested_at) - new Date(a.requested_at));

    return res.status(200).json({
      success: true,
      data: withdrawals
    });

  } catch (error) {
    console.error('Get all withdrawals error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to get withdrawals'
    });
  }
}

// Admin: Process withdrawal (simulated)
async function processWithdrawal(req, res, supabase) {
  if (req.method !== 'POST') {
    return res.status(405).json({ success: false, error: 'Method not allowed' });
  }

  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ success: false, error: 'No authorization header' });
  }

  const token = authHeader.replace('Bearer ', '');
  const { data: { user }, error: authError } = await supabase.auth.getUser(token);
  
  if (authError || !user) {
    return res.status(401).json({ success: false, error: 'Invalid token' });
  }

  // Check if user is admin (simulated)
  if (!user.email.includes('admin')) {
    return res.status(403).json({ success: false, error: 'Admin access required' });
  }

  const { withdrawal_id, action, admin_notes } = req.body;

  if (!withdrawal_id || !action || !['approve', 'reject'].includes(action)) {
    return res.status(400).json({
      success: false,
      error: 'Withdrawal ID and valid action (approve/reject) are required'
    });
  }

  try {
    const withdrawal = simulatedData.withdrawals.get(withdrawal_id);
    
    if (!withdrawal) {
      return res.status(404).json({
        success: false,
        error: 'Withdrawal request not found'
      });
    }

    if (withdrawal.status !== 'pending') {
      return res.status(400).json({
        success: false,
        error: 'Withdrawal request has already been processed'
      });
    }

    const newStatus = action === 'approve' ? 'approved' : 'rejected';

    // If approving, deduct from wallet balance
    if (action === 'approve') {
      const wallet = simulatedData.wallets.get(withdrawal.participant_id);
      
      if (!wallet || wallet.balance < withdrawal.amount) {
        return res.status(400).json({
          success: false,
          error: 'Insufficient wallet balance'
        });
      }

      // Update wallet balance
      wallet.balance -= withdrawal.amount;
      wallet.total_withdrawn += withdrawal.amount;
      wallet.updated_at = new Date().toISOString();
      simulatedData.wallets.set(withdrawal.participant_id, wallet);

      // Create transaction record
      const transaction = {
        id: generateId(),
        wallet_id: wallet.id,
        transaction_type: 'withdrawal',
        amount: -withdrawal.amount,
        balance_before: wallet.balance + withdrawal.amount,
        balance_after: wallet.balance,
        reference_type: 'withdrawal_request',
        reference_id: withdrawal.id,
        description: `Withdrawal processed - ${withdrawal.payment_method}`,
        created_by: user.id,
        created_at: new Date().toISOString()
      };

      simulatedData.transactions.set(transaction.id, transaction);
    }

    // Update withdrawal status
    withdrawal.status = newStatus;
    withdrawal.admin_notes = admin_notes;
    withdrawal.processed_at = new Date().toISOString();
    withdrawal.processed_by = user.id;
    withdrawal.updated_at = new Date().toISOString();

    simulatedData.withdrawals.set(withdrawal_id, withdrawal);

    return res.status(200).json({
      success: true,
      data: withdrawal,
      message: `Withdrawal ${action}ed successfully`
    });

  } catch (error) {
    console.error('Process withdrawal error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to process withdrawal'
    });
  }
}

// Admin: Get all wallets (simulated)
async function getAllWallets(req, res, supabase) {
  if (req.method !== 'GET') {
    return res.status(405).json({ success: false, error: 'Method not allowed' });
  }

  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ success: false, error: 'No authorization header' });
  }

  const token = authHeader.replace('Bearer ', '');
  const { data: { user }, error: authError } = await supabase.auth.getUser(token);
  
  if (authError || !user) {
    return res.status(401).json({ success: false, error: 'Invalid token' });
  }

  // Check if user is admin (simulated)
  if (!user.email.includes('admin')) {
    return res.status(403).json({ success: false, error: 'Admin access required' });
  }

  try {
    const wallets = Array.from(simulatedData.wallets.values())
      .map(w => ({
        ...w,
        participant: {
          name: 'Simulated Participant',
          email: 'participant@example.com'
        }
      }))
      .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

    return res.status(200).json({
      success: true,
      data: wallets
    });

  } catch (error) {
    console.error('Get all wallets error:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to get wallets'
    });
  }
}
